<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Assistant Chatbot</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        display: flex;
        flex-direction: column;
    }
    .container {
        display: flex;
        width: 80%;
        margin: auto;
        margin-top: 20px;
    }
    .sidebar {
        width: 250px;
        border: 1px solid #ccc;
        border-radius: 10px;
        background-color: #f9f9f9;
        padding: 10px;
        margin-right: 20px;
        overflow-y: auto;
        max-height: 560px;
        min-height: 560px;
    }
    .sidebar h3 {
        margin-top: 0;
    }
    .session-item {
        padding: 8px;
        border-bottom: 1px solid #ddd;
        cursor: pointer;
        background-color: #fff;
        margin-bottom: 5px;
        border-radius: 5px;
    }
    .session-item:hover {
        background-color: #e9ecef;
    }
    .chat-box {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        border: 1px solid #ccc;
        border-radius: 10px;
        background-color: white;
        overflow: hidden;
        width: 50%;
        margin:0 auto;
        max-height: 560px;
        min-height: 560px;
    }
    .chat-container {
        flex-grow: 1;
        padding: 10px;
        overflow-y: scroll;
    }
    .message {
        padding: 10px 15px;
        border-radius: 20px;
        max-width: 75%;
        margin: 10px 0;
        word-wrap: break-word;
        position: relative;
    }
    .message .speak-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
    }
    .user-message {
        background-color: #395AC7;
        color: white;
        margin-left: auto;
        text-align: right;
    }
    .assistant-message {
        background-color: #EAEAEA;
        color: black;
        text-align: left;
    }
    .input-box {
        display: flex;
        padding: 10px;
        border-top: 1px solid #ccc;
        background-color: #fff;
    }
    .input-box input {
        flex-grow: 1;
        padding: 10px 15px;
        border-radius: 20px;
        border: 1px solid #ccc;
        font-size: 16px;
        outline: none;
    }
    .input-box button {
        margin-left: 10px;
        padding: 10px 20px;
        border-radius: 20px;
        border: none;
        background-color: #395AC7;
        color: white;
        cursor: pointer;
        font-size: 16px;
    }
    .input-box #voice-btn {
        margin-left: 5px;
        padding: 10px;
        border-radius: 50%;
        border: none;
        background-color: #28a745;
        color: white;
        cursor: pointer;
        font-size: 16px;
    }
    .command-buttons {
        display: flex;
        justify-content: center;
        margin: 10px 0;
        gap: 10px;
        flex-wrap: wrap;
    }
    .command-buttons button {
        padding: 8px 15px;
        border-radius: 15px;
        border: none;
        background-color: #28a745;
        color: white;
        cursor: pointer;
        flex: 1 1 45%;
        max-width: 150px;
    }
    .realtime-controls {
        display: none;
        margin: 10px 0;
        text-align: center;
    }
    .realtime-controls button {
        padding: 10px 20px;
        margin: 0 5px;
        border-radius: 5px;
        border: none;
        cursor: pointer;
        font-size: 16px;
    }
    .realtime-controls #startRealtimeBtn {
        background-color: #007bff;
        color: white;
    }
    .realtime-controls #stopRealtimeBtn {
        background-color: #dc3545;
        color: white;
    }
    @media (max-width: 600px) {
        .command-buttons button {
            flex: 1 1 48%;
        }
    }
</style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <h3>Previous Sessions</h3>
        <div id="sessions-list"></div>
    </div>
    <div class="chat-box">
    <div class="chat-container" id="chat-container"></div>

    <form class="input-box" id="chat-form">
        <input type="text" id="user_input" placeholder="Type your message..." required>
        <button type="submit">Send</button>
        <button id="voice-btn" type="button">ðŸŽ¤</button>
    </form>

    <div class="command-buttons">
        <button id="new-session-btn">New Session</button>
        <button id="restart-btn">Restart</button>
        <button id="clear-btn">Clear</button>
        <button id="show-history-btn">Show History</button>
        <button id="realtime-btn">Real-Time Chat</button>
    </div>

    <div class="realtime-controls" id="realtime-controls">
        <button id="startRealtimeBtn">Start Real-Time</button>
        <button id="stopRealtimeBtn" disabled>Stop Real-Time</button>
    </div>
</div>

<script>
const sessionsList = document.getElementById('sessions-list');

// Fetch sessions from backend
async function fetchSessions() {
    try {
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat?action=sessions', {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const data = await response.json();
            return data.sessions || [];
        } else {
            console.error('Failed to fetch sessions from backend');
        }
    } catch (error) {
        console.error('Error fetching sessions:', error);
    }
    return [];
}

// Fetch session history from backend
async function fetchSessionHistory(sessionId) {
    try {
        const response = await fetch(`https://my-chatbot-func-00.azurewebsites.net/api/online-chat?session_id=${sessionId}&action=history`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const data = await response.json();
            return data.history || [];
        } else {
            console.error('Failed to fetch session history from backend');
        }
    } catch (error) {
        console.error('Error fetching session history:', error);
    }
    return [];
}

// Load sessions from backend
async function loadSessions() {
    const sessions = await fetchSessions();
    sessionsList.innerHTML = '';
    sessions.forEach((session, index) => {
        const sessionDiv = document.createElement('div');
        sessionDiv.classList.add('session-item');
        sessionDiv.textContent = `Session ${index + 1}: ${session.title || 'Untitled'}`;
        sessionDiv.onclick = () => loadSession(session.id);
        sessionsList.appendChild(sessionDiv);
    });
}

// Load a session from backend
async function loadSession(sessionIdToLoad) {
    const history = await fetchSessionHistory(sessionIdToLoad);
    sessionId = sessionIdToLoad;
    localStorage.setItem('sessionId', sessionId);
    chatContainer.innerHTML = '';
    history.forEach(msg => {
        addMessage(msg.text, msg.isUser);
    });
}

// Load sessions on page load
window.addEventListener('load', () => {
    loadSessions();
    
});
const chatForm = document.getElementById('chat-form');
const userInput = document.getElementById('user_input');
const chatContainer = document.getElementById('chat-container');
const voiceBtn = document.getElementById('voice-btn');
const newSessionBtn = document.getElementById('new-session-btn');
const restartBtn = document.getElementById('restart-btn');
const clearBtn = document.getElementById('clear-btn');
const showHistoryBtn = document.getElementById('show-history-btn');
const realtimeBtn = document.getElementById('realtime-btn');
const realtimeControls = document.getElementById('realtime-controls');
const startRealtimeBtn = document.getElementById('startRealtimeBtn');
const stopRealtimeBtn = document.getElementById('stopRealtimeBtn');

// Generate or retrieve a session ID from backend
let sessionId = localStorage.getItem('sessionId');

async function fetchSessionId() {
    try {
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat', {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const data = await response.json();
            if (data.session_id) {
                sessionId = data.session_id;
                localStorage.setItem('sessionId', sessionId);
            }
        } else {
            console.error('Failed to fetch session ID from backend');
        }
    } catch (error) {
        console.error('Error fetching session ID:', error);
    }
}

if (!sessionId) {
    fetchSessionId();
}

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Speech recognition
let recognition;
let isListening = false;
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    recognition.continuous = true;
    recognition.interimResults = false;
    recognition.lang = 'en-US';

    voiceBtn.addEventListener('click', () => {
        if (isListening) {
            recognition.stop();
            isListening = false;
            voiceBtn.textContent = 'ðŸŽ¤';
        } else {
            recognition.start();
            isListening = true;
            voiceBtn.textContent = 'ðŸŽ™ï¸';
        }
    });

    recognition.onresult = (event) => {
        const transcript = event.results[event.results.length - 1][0].transcript;
        userInput.value = transcript;
        chatForm.dispatchEvent(new Event('submit'));
    };

    recognition.onerror = () => {
        isListening = false;
        voiceBtn.textContent = 'ðŸŽ¤';
        addMessage('Speech recognition error', false);
    };

    recognition.onend = () => {
        isListening = false;
        voiceBtn.textContent = 'ðŸŽ¤';
    };
} else {
    voiceBtn.style.display = 'none';
}

function addMessage(text, isUser = false) {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add(isUser ? 'user-message' : 'assistant-message');
    messageDiv.textContent = text;
    chatContainer.appendChild(messageDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

function addTypingEffect(text) {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', 'assistant-message');
    chatContainer.appendChild(messageDiv);

    let index = 0;
    function typeChar() {
        messageDiv.textContent = text.slice(0, index + 1);
        index++;
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (index < text.length) {
            setTimeout(typeChar, 20);
        }
    }
    typeChar();
}

async function sendMessage(message) {
    if (!message.trim()) return;
    if (!sessionId) sessionId = generateUUID();

    addMessage(message, true);
    userInput.value = '';

    try {
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_input: message, session_id: sessionId })
        });
        console.log('Response status:', response.status);

        if (!response.ok) {
            addMessage('Error: ' + response.statusText, false);
            return;
        }

        const data = await response.json();
        if (data.response) addTypingEffect(data.response);
        else addMessage('Error: Invalid response from server', false);
    } catch (err) {
        addMessage('Error: Could not reach server', false);
    }
}

function sendCommand(cmd) {
    sendMessage(cmd);
}

// Form submission
chatForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const message = userInput.value.trim();
    if (message) sendMessage(message);
});

// Enter key shortcut
userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') chatForm.dispatchEvent(new Event('submit'));
});

// Command buttons
newSessionBtn.addEventListener('click', () => {
    sessionId = generateUUID();
    localStorage.setItem('sessionId', sessionId);
    chatContainer.innerHTML = '';
    addTypingEffect("New session started. Hello! I am your AI assistant. Ask me anything related to AI.");
    loadSessions(); // Refresh the sessions list
});
restartBtn.addEventListener('click', () => sendCommand('restart'));
clearBtn.addEventListener('click', () => {
    chatContainer.innerHTML = '';
    sendCommand('clear');
});
showHistoryBtn.addEventListener('click', () => sendCommand('show history'));
realtimeBtn.addEventListener('click', () => {
    realtimeControls.style.display = 'block';
});

///////////////////////////
/////real time gpt////////
/////////////////////////

let realtimeSocket = null;
let mediaRecorder = null;
let audioContext = null;
let stream = null;
let audioBuffer = [];
let currentAssistantMessage = null;
let ragPromise = null;
let isAssistantSpeaking = false;

async function fetchRAG(question) {
    try {
        console.log('Fetching RAG for question:', question);
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_input: question, session_id: sessionId })
        });
        console.log('RAG fetch response status:', response.status);
        if (response.ok) {
            const data = await response.json();
            console.log('RAG fetch data:', data);
            return data.response || 'The topic you re asking about doesnt match the topics found in the current documents, so I cant recommend courses on that.';
        } else {
            console.log('RAG fetch failed with status:', response.status);
            return 'No additional information available.';
        }
    } catch (err) {
        console.log('RAG fetch error:', err);
        return 'Error fetching information.';
    }
}

// Start real-time chat
startRealtimeBtn.addEventListener('click', async () => {
    startRealtimeBtn.disabled = true;
    stopRealtimeBtn.disabled = false;
    addMessage('Real-time chat started. Speak now!', false);

    try {
        if (!isAssistantSpeaking) {
            // Get microphone
            stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioContext = new AudioContext({ sampleRate: 24000 });
            await audioContext.resume();

            // Connect to Azure OpenAI Realtime API
            realtimeSocket = new WebSocket(
                'wss://oai-internship-eus2.openai.azure.com/openai/realtime?api-version=2024-10-01-preview&deployment=gpt-4o-realtime-preview&api-key=BQslq711tLVVvTUCCjD1uOCjWSOn4JyOJQFTIf7vqI3JHZL0whqkJQQJ99BIACHYHv6XJ3w3AAABACOGVUCM'
            );

            realtimeSocket.onopen = () => {
                console.log('WebSocket connected');

                // Send session configuration
                realtimeSocket.send(JSON.stringify({
                    type: 'session.update',
                    session: {
                        modalities: ['text', 'audio'],
                        instructions: "You are an AI assistant specialized in AI. Always respond in English.",
                        voice: 'alloy',
                        input_audio_format: 'pcm16',
                        output_audio_format: 'pcm16',
                        input_audio_transcription: { model: 'whisper-1', language: 'en' },
                        turn_detection: { type: 'server_vad' },
                        temperature: 0.8,
                        tools: [],
                        tool_choice: 'auto',
                        max_response_output_tokens: 4096
                    }
                }));

                startRecording();
            };

            let assistantAudioChunks = [];

            realtimeSocket.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                console.log('Received:', message);

                // Collect PCM16 chunks (delta or full audio)
                if ((message.type === 'response.audio.delta' && message.delta) ||
                    (message.type === 'response.audio' && message.audio)) {
                    const audioBase64 = message.delta || message.audio;
                    assistantAudioChunks.push(base64ToArrayBuffer(audioBase64));
                }

                // When assistant finishes speaking
                if (message.type === 'response.done') {
                    if (assistantAudioChunks.length === 0) {
                        console.warn('No audio chunks received');
                        return;
                    }

                    // Merge all chunks
                    const totalLength = assistantAudioChunks.reduce((sum, buf) => sum + buf.byteLength, 0);
                    const combined = new Uint8Array(totalLength);
                    let offset = 0;
                    assistantAudioChunks.forEach(buf => {
                        combined.set(new Uint8Array(buf), offset);
                        offset += buf.byteLength;
                    });

                    // Play the combined audio
                    isAssistantSpeaking = true;
                    playAudio(combined.buffer, () => { 
                        isAssistantSpeaking = false; 
                    });

                    assistantAudioChunks = [];
                }

                // Text transcription
                if (message.type === 'conversation.item.input_audio_transcription.completed') {
                    const transcript = message.transcript;
                    if (transcript && transcript.trim()) {
                        addMessage(transcript, true); // show user's question

                        fetchRAG(transcript).then(ragResponse => {
                            if (ragResponse && realtimeSocket.readyState === WebSocket.OPEN) {
                                // Send assistant's response in English + audio
                                realtimeSocket.send(JSON.stringify({
                                    type: 'response.create',
                                    response: {
                                        modalities: ['text', 'audio'],
                                        instructions: ragResponse,
                                        voice: 'alloy'
                                    }
                                }));

                                // Show assistant text immediately
                                addTypingEffect(ragResponse);
                            }
                        });
                    }
                }
            };

            realtimeSocket.onerror = (err) => console.error('WebSocket error:', err);
            realtimeSocket.onclose = () => stopRecording();
        }
    } catch (error) {
        console.error('Error starting real-time chat:', error);
        addMessage('Failed to start real-time chat: ' + error.message, false);
        startRealtimeBtn.disabled = false;
        stopRealtimeBtn.disabled = true;
    }
});

// Stop real-time chat
stopRealtimeBtn.addEventListener('click', () => {
    startRealtimeBtn.disabled = false;
    stopRealtimeBtn.disabled = true;
    addMessage('Real-time chat stopped.', false);

    if (realtimeSocket) {
        realtimeSocket.close();
        realtimeSocket = null;
    }
    stopRecording();
});

// Record mic and send to assistant
function startRecording() {
    if (!stream || !audioContext) return;

    const source = audioContext.createMediaStreamSource(stream);
    const processor = audioContext.createScriptProcessor(4096, 1, 1);

    processor.onaudioprocess = (event) => {
        if (isAssistantSpeaking) return; // pause mic while assistant speaks
        if (realtimeSocket && realtimeSocket.readyState === WebSocket.OPEN) {
            const inputData = event.inputBuffer.getChannelData(0);
            const pcm16 = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) pcm16[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));

            realtimeSocket.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: arrayBufferToBase64(pcm16.buffer) }));
        }
    };

    source.connect(processor);
    processor.connect(audioContext.destination);
}

function stopRecording() {
    if (stream) stream.getTracks().forEach(track => track.stop());
    stream = null;

    if (audioContext) {
        audioContext.close();
        audioContext = null;
    }
}

// Play PCM16 buffer with callback
async function playAudio(arrayBuffer, callback) {
    if (!audioContext) audioContext = new AudioContext({ sampleRate: 24000 });
    if (audioContext.state === 'suspended') await audioContext.resume();

    const int16 = new Int16Array(arrayBuffer);
    const float32 = new Float32Array(int16.length);
    for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;

    const buffer = audioContext.createBuffer(1, float32.length, audioContext.sampleRate);
    buffer.copyToChannel(float32, 0);

    const source = audioContext.createBufferSource();
    source.buffer = buffer;
    source.connect(audioContext.destination);
    source.start();
    source.onended = () => { if (callback) callback(); };
}



function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

function base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

// Welcome message
window.addEventListener('load', () => {
    addTypingEffect("Hello! I am your AI assistant. Ask me anything related to AI.");
});
</script>
</body>
</html>
