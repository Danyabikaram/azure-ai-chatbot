<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Assistant Chatbot</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        display: flex;
        flex-direction: column;
    }
    .container {
        display: flex;
        width: 80%;
        margin: auto;
        margin-top: 20px;
    }
    .sidebar {
        width: 250px;
        border: 1px solid #ccc;
        border-radius: 10px;
        background-color: #f9f9f9;
        padding: 10px;
        margin-right: 20px;
        overflow-y: auto;
        max-height: 560px;
        min-height: 560px;
    }
    .sidebar h3 {
        margin-top: 0;
    }
    .session-item {
        padding: 8px;
        border-bottom: 1px solid #ddd;
        cursor: pointer;
        background-color: #fff;
        margin-bottom: 5px;
        border-radius: 5px;
    }
    .session-item:hover {
        background-color: #e9ecef;
    }
    .chat-box {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        border: 1px solid #ccc;
        border-radius: 10px;
        background-color: white;
        overflow: hidden;
        width: 50%;
        margin:0 auto;
        max-height: 560px;
        min-height: 560px;
    }
    .chat-container {
        flex-grow: 1;
        padding: 10px;
        overflow-y: scroll;
    }
    .message {
        padding: 10px 15px;
        border-radius: 20px;
        max-width: 75%;
        margin: 10px 0;
        word-wrap: break-word;
        position: relative;
    }
    .message .speak-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
    }
    .user-message {
        background-color: #395AC7;
        color: white;
        margin-left: auto;
        text-align: right;
    }
    .assistant-message {
        background-color: #EAEAEA;
        color: black;
        text-align: left;
    }
    .input-box {
        display: flex;
        padding: 10px;
        border-top: 1px solid #ccc;
        background-color: #fff;
    }
    .input-box input {
        flex-grow: 1;
        padding: 10px 15px;
        border-radius: 20px;
        border: 1px solid #ccc;
        font-size: 16px;
        outline: none;
    }
    .input-box button {
        margin-left: 10px;
        padding: 10px 20px;
        border-radius: 20px;
        border: none;
        background-color: #395AC7;
        color: white;
        cursor: pointer;
        font-size: 16px;
    }
    .input-box #voice-btn {
        margin-left: 5px;
        padding: 10px;
        border-radius: 50%;
        border: none;
        background-color: #28a745;
        color: white;
        cursor: pointer;
        font-size: 16px;
    }
    .command-buttons {
        display: flex;
        justify-content: center;
        margin: 10px 0;
        gap: 10px;
        flex-wrap: wrap;
    }
    .command-buttons button {
        padding: 8px 15px;
        border-radius: 15px;
        border: none;
        background-color: #28a745;
        color: white;
        cursor: pointer;
        flex: 1 1 45%;
        max-width: 150px;
    }
    .realtime-controls {
        display: none;
        margin: 10px 0;
        text-align: center;
    }
    .realtime-controls button {
        padding: 10px 20px;
        margin: 0 5px;
        border-radius: 5px;
        border: none;
        cursor: pointer;
        font-size: 16px;
    }
    .realtime-controls #startRealtimeBtn {
        background-color: #007bff;
        color: white;
    }
    .realtime-controls #stopRealtimeBtn {
        background-color: #dc3545;
        color: white;
    }
    @media (max-width: 600px) {
        .command-buttons button {
            flex: 1 1 48%;
        }
    }
</style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <h3>Previous Sessions</h3>
        <div id="sessions-list"></div>
    </div>
    <div class="chat-box">
    <div class="chat-container" id="chat-container"></div>

    <form class="input-box" id="chat-form">
        <input type="text" id="user_input" placeholder="Type your message..." required>
        <button type="submit">Send</button>
        <button id="voice-btn" type="button">🎤</button>
    </form>

    <div class="command-buttons">
        <button id="new-session-btn">New Session</button>
        <button id="restart-btn">Restart</button>
        <button id="clear-btn">Clear</button>
        <button id="show-history-btn">Show History</button>
        <button id="realtime-btn">Real-Time Chat</button>
    </div>

    <div class="realtime-controls" id="realtime-controls">
        <button id="startRealtimeBtn">Start Real-Time</button>
        <button id="stopRealtimeBtn" disabled>Stop Real-Time</button>
    </div>
</div>

<script>
const sessionsList = document.getElementById('sessions-list');

// Fetch sessions from backend
async function fetchSessions() {
    try {
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat?action=sessions', {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const data = await response.json();
            return data.sessions || [];
        } else {
            console.error('Failed to fetch sessions from backend');
        }
    } catch (error) {
        console.error('Error fetching sessions:', error);
    }
    return [];
}

// Fetch session history from backend
async function fetchSessionHistory(sessionId) {
    try {
        const response = await fetch(`https://my-chatbot-func-00.azurewebsites.net/api/online-chat?session_id=${sessionId}&action=history`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const data = await response.json();
            return data.history || [];
        } else {
            console.error('Failed to fetch session history from backend');
        }
    } catch (error) {
        console.error('Error fetching session history:', error);
    }
    return [];
}

// Load sessions from backend
async function loadSessions() {
    const sessions = await fetchSessions();
    sessionsList.innerHTML = '';
    sessions.forEach((session, index) => {
        const sessionDiv = document.createElement('div');
        sessionDiv.classList.add('session-item');
        sessionDiv.textContent = `Session ${index + 1}: ${session.title || 'Untitled'}`;
        sessionDiv.onclick = () => loadSession(session.id);
        sessionsList.appendChild(sessionDiv);
    });
}

// Load a session from backend
async function loadSession(sessionIdToLoad) {
    const history = await fetchSessionHistory(sessionIdToLoad);
    sessionId = sessionIdToLoad;
    localStorage.setItem('sessionId', sessionId);
    chatContainer.innerHTML = '';
    history.forEach(msg => {
        addMessage(msg.text, msg.isUser);
    });
}

// Load sessions on page load
window.addEventListener('load', () => {
    loadSessions();
    
});
const chatForm = document.getElementById('chat-form');
const userInput = document.getElementById('user_input');
const chatContainer = document.getElementById('chat-container');
const voiceBtn = document.getElementById('voice-btn');
const newSessionBtn = document.getElementById('new-session-btn');
const restartBtn = document.getElementById('restart-btn');
const clearBtn = document.getElementById('clear-btn');
const showHistoryBtn = document.getElementById('show-history-btn');
const realtimeBtn = document.getElementById('realtime-btn');
const realtimeControls = document.getElementById('realtime-controls');
const startRealtimeBtn = document.getElementById('startRealtimeBtn');
const stopRealtimeBtn = document.getElementById('stopRealtimeBtn');

// Generate or retrieve a session ID from backend
let sessionId = localStorage.getItem('sessionId');

async function fetchSessionId() {
    try {
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat', {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const data = await response.json();
            if (data.session_id) {
                sessionId = data.session_id;
                localStorage.setItem('sessionId', sessionId);
            }
        } else {
            console.error('Failed to fetch session ID from backend');
        }
    } catch (error) {
        console.error('Error fetching session ID:', error);
    }
}

if (!sessionId) {
    fetchSessionId();
}

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Speech recognition
let recognition;
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-US';

    voiceBtn.addEventListener('click', () => {
        recognition.start();
        voiceBtn.textContent = '🎙️';
    });

    recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        userInput.value = transcript;
        voiceBtn.textContent = '🎤';
        chatForm.dispatchEvent(new Event('submit'));
    };

    recognition.onerror = () => {
        voiceBtn.textContent = '🎤';
        addMessage('Speech recognition error', false);
    };

    recognition.onend = () => {
        voiceBtn.textContent = '🎤';
    };
} else {
    voiceBtn.style.display = 'none';
}

function addMessage(text, isUser = false) {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add(isUser ? 'user-message' : 'assistant-message');
    messageDiv.textContent = text;
    chatContainer.appendChild(messageDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

function addTypingEffect(text) {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', 'assistant-message');
    chatContainer.appendChild(messageDiv);

    let index = 0;
    function typeChar() {
        messageDiv.textContent = text.slice(0, index + 1);
        index++;
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (index < text.length) {
            setTimeout(typeChar, 20);
        } else {
            const speakBtn = document.createElement('button');
            speakBtn.classList.add('speak-btn');
            speakBtn.textContent = '🔊';
            speakBtn.onclick = () => {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    speechSynthesis.speak(utterance);
                }
            };
            messageDiv.appendChild(speakBtn);
        }
    }
    typeChar();
}

async function sendMessage(message) {
    if (!message.trim()) return;
    if (!sessionId) sessionId = generateUUID();

    addMessage(message, true);
    userInput.value = '';

    try {
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_input: message, session_id: sessionId })
        });
        console.log('Response status:', response.status);

        if (!response.ok) {
            addMessage('Error: ' + response.statusText, false);
            return;
        }

        const data = await response.json();
        if (data.response) addTypingEffect(data.response);
        else addMessage('Error: Invalid response from server', false);
    } catch (err) {
        addMessage('Error: Could not reach server', false);
    }
}

function sendCommand(cmd) {
    sendMessage(cmd);
}

// Form submission
chatForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const message = userInput.value.trim();
    if (message) sendMessage(message);
});

// Enter key shortcut
userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') chatForm.dispatchEvent(new Event('submit'));
});

// Command buttons
newSessionBtn.addEventListener('click', () => {
    sessionId = generateUUID();
    localStorage.setItem('sessionId', sessionId);
    chatContainer.innerHTML = '';
    addTypingEffect("New session started. Hello! I am your AI assistant. Ask me anything related to AI.");
    loadSessions(); // Refresh the sessions list
});
restartBtn.addEventListener('click', () => sendCommand('restart'));
clearBtn.addEventListener('click', () => {
    chatContainer.innerHTML = '';
    sendCommand('clear');
});
showHistoryBtn.addEventListener('click', () => sendCommand('show history'));
realtimeBtn.addEventListener('click', () => {
    realtimeControls.style.display = 'block';
});

let realtimeSocket = null;
let mediaRecorder = null;
let audioContext = null;
let stream = null;
let audioBuffer = [];
let currentAssistantMessage = null;
let ragPromise = null;
let isAssistantSpeaking = false;

async function fetchRAG(question) {
    try {
        console.log('Fetching RAG for question:', question);
        const response = await fetch('https://my-chatbot-func-00.azurewebsites.net/api/online-chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_input: question, session_id: sessionId })
        });
        console.log('RAG fetch response status:', response.status);
        if (response.ok) {
            const data = await response.json();
            console.log('RAG fetch data:', data);
            return data.response || 'No additional information available.';
        } else {
            console.log('RAG fetch failed with status:', response.status);
            return 'No additional information available.';
        }
    } catch (err) {
        console.log('RAG fetch error:', err);
        return 'Error fetching information.';
    }
}

startRealtimeBtn.addEventListener('click', async () => {
    startRealtimeBtn.disabled = true;
    stopRealtimeBtn.disabled = false;
    addMessage('Real-time chat started. Speak now!', false);

    try {
        // Get microphone access
        if(!isAssistantSpeaking){
        
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext({ sampleRate: 24000 });
        await audioContext.resume();

        // Connect to Azure OpenAI Realtime API
        realtimeSocket = new WebSocket('wss://oai-internship-eus2.openai.azure.com/openai/realtime?api-version=2024-10-01-preview&deployment=gpt-4o-realtime-preview&api-key=BQslq711tLVVvTUCCjD1uOCjWSOn4JyOJQFTIf7vqI3JHZL0whqkJQQJ99BIACHYHv6XJ3w3AAABACOGVUCM');

        realtimeSocket.onopen = () => {
            console.log('WebSocket connected');
            // Send session configuration
            realtimeSocket.send(JSON.stringify({
                type: 'session.update',
                session: {
                    modalities: ['text', 'audio'],
                    instructions: "You are an AI assistant specialized in AI. When the answer exists in the retrieved documents, respond directly without mentioning the documents. If the user asks about learning a topic that is related to the documents, use the get_course_recommendations function. If the topic is unrelated, politely say the topic is outside the current scope. Always provide references when possible. After each answer, ask if you can assist with anything else.",
                    voice: 'alloy',
                    input_audio_format: 'pcm16',
                    output_audio_format: 'pcm16',
                    input_audio_transcription: { model: 'whisper-1', language: 'en' },
                    turn_detection: { type: 'server_vad' },
                    tools: [],
                    tool_choice: 'auto',
                    temperature: 0.8,
                    max_response_output_tokens: 4096
                }
            }));

            // Start recording and sending audio
            startRecording();
        };

        realtimeSocket.onmessage = async (event) => {
            const message = JSON.parse(event.data);
            console.log('Received:', message);

            if (message.type === 'conversation.item.input_audio_transcription.completed') {
                // Transcription completed, add user message and respond with RAG if available
                const transcript = message.transcript;
                if (transcript && transcript.trim()) {
                    addMessage(transcript, true);
                    fetchRAG(transcript).then(ragResponse => {
                        if (ragResponse && ragResponse !== 'No additional information available.' && ragResponse !== 'Error fetching information.') {
                            addTypingEffect(ragResponse);
                            if ('speechSynthesis' in window) {
                                isAssistantSpeaking = true;
                                const utterance = new SpeechSynthesisUtterance(ragResponse);
                                utterance.onend = () => { isAssistantSpeaking = false; };
                                speechSynthesis.speak(utterance);
                            }
                        }
                    });
                }
            } else if (message.type === 'response.done') {
                // Response completed
                isAssistantSpeaking = false;
            }
        };

     
        realtimeSocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            addMessage('Real-time connection error', false);
        };

        realtimeSocket.onclose = () => {
            console.log('WebSocket closed');
            stopRecording();
        };
    }
    } catch (error) {
        console.error('Error starting real-time chat:', error);
        addMessage('Failed to start real-time chat: ' + error.message, false);
        startRealtimeBtn.disabled = false;
        stopRealtimeBtn.disabled = true;
    }
    
});

stopRealtimeBtn.addEventListener('click', () => {
    startRealtimeBtn.disabled = false;
    stopRealtimeBtn.disabled = true;
    addMessage('Real-time chat stopped.', false);

    if (realtimeSocket) {
        realtimeSocket.close();
        realtimeSocket = null;
    }
    stopRecording();
});

function startRecording() {
    if (!stream) return;

    const source = audioContext.createMediaStreamSource(stream);
    const processor = audioContext.createScriptProcessor(4096, 1, 1);

    processor.onaudioprocess = (event) => {
        if (realtimeSocket && realtimeSocket.readyState === WebSocket.OPEN && !isAssistantSpeaking) {
            const inputBuffer = event.inputBuffer;
            const inputData = inputBuffer.getChannelData(0);

            // Convert to PCM16
            const pcm16 = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) {
                pcm16[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
            }

            // Send audio data
            realtimeSocket.send(JSON.stringify({
                type: 'input_audio_buffer.append',
                audio: arrayBufferToBase64(pcm16.buffer)
            }));
        }
    };

    source.connect(processor);
    processor.connect(audioContext.destination);
}

function stopRecording() {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
    }
    if (audioContext) {
        audioContext.close();
        audioContext = null;
    }
}

function playAudio(audioData) {
    const audioBuffer = base64ToArrayBuffer(audioData);
    const int16Array = new Int16Array(audioBuffer);

    // Convert PCM16 to Float32
    const float32Array = new Float32Array(int16Array.length);
    for (let i = 0; i < int16Array.length; i++) {
        float32Array[i] = int16Array[i] / 32768;
    }

    // Create audio buffer and play
    const audioBufferObj = audioContext.createBuffer(1, float32Array.length, 24000);
    audioBufferObj.copyFromChannel(float32Array, 0);

    const source = audioContext.createBufferSource();
    source.buffer = audioBufferObj;
    source.connect(audioContext.destination);
    source.start();
}

function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

function base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

// Welcome message
window.addEventListener('load', () => {
    addTypingEffect("Hello! I am your AI assistant. Ask me anything related to AI.");
});
</script>
</body>
</html>
